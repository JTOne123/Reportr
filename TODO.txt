TODO:
-----

*** TableDefinition (that defines schema and which query to use etc)
*** ITable (e.g. FlatTable etc)
*** Same with ReportDefinition (that contains schema) and IReport which contains generated output
	*** Also need ReportSectionDefinition and IReportSection or ReportSection


*** IDateItem (can be used with ReportAction)


*** How do report template contents tell us their size? How about optional "promised" row height? table header and footer height? Chart height? Then we can calculate page sizes


*** Component optional relative width and height (%)
	- And margin (top/left/right/bottom width and unit)
*** Report template page optional size (units e.g. %, pixels cm etc) of width and height so we can auto paginate
	- Also add margin details (for printing and screen padding)
*** How do we calculate actual height of section so we can paginate?
*** Binding of query result to component structure which allows template to auto generate
	- For repeater, if no binding specified them entire result is the value given
	- Can we add an IsDefined function to Nettle so we can see if property exists?

- Create default IReport implementation
	- Refactor sections as report items and put into a "Detail" collection in IReport
		- See https://docs.telerik.com/reporting/designing-reports-understanding-report-structure
	- Create new report section concept which is used to vertically split the report (into rows) and this becomes (optional header, footer etc) with mandatory detail section

- Design report auto export mechanism (e.g. CSV, XML, JSON etc)
	- See https://github.com/danielpalme/ReportGenerator

- Consider how report rendering could work (with different report and section templates etc)
	- Remove association between report/section and template
	- Create rendering engine that takes the report output and a template at the same time
		- Then each template can specify an output type (e.g. HTML)
		- Each template then has a nested collection of templates for sections and report items (of each type - i.e. one for each type of Chart, queries etc)
		- So when you specify a template at render time, it knows what templates to use for every type of child component
		- Refactor templates and abstract into interfaces


Low Priority:
-------------

- Integrate with Nettle

- Create report component mocking (e.g. generate fake data for chart) for report building and testing

- Create report builder with storage mechanism
